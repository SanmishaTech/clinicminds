// src/app/api/sales/route.ts
import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { Success, Error, BadRequest } from '@/lib/api-response';
import { guardApiAccess } from '@/lib/access-guard';
import { paginate } from '@/lib/paginate';
import { createSaleSchema, type CreateSaleInput } from '@/lib/schemas/backend/sales';
import { z } from 'zod';
// GET /api/sales
export async function GET(req: NextRequest) {
  const auth = await guardApiAccess(req);
  if (!auth.ok) return auth.response;
  const { searchParams } = new URL(req.url);
  const page = Math.max(1, parseInt(searchParams.get('page') || '1'));
  const perPage = Math.min(50, Math.max(1, parseInt(searchParams.get('perPage') || '10')));
  const search = searchParams.get('search')?.trim() || '';
  const franchiseId = searchParams.get('franchiseId') ? parseInt(searchParams.get('franchiseId')!) : undefined;
  const startDate = searchParams.get('startDate');
  const endDate = searchParams.get('endDate');

  try {
    const where: any = {};
    
    // Check if user is admin first to avoid unnecessary database queries
    if (auth.user.role === 'Admin') {
      // Admin can optionally filter by specific franchise
      if (franchiseId) {
        where.franchiseId = franchiseId;
      }
    } else {
      // For non-admin users, get their franchise info and filter accordingly
      const currentUser = await prisma.user.findUnique({
        where: { id: auth.user.id },
        select: { 
          id: true,
          franchise: {
            select: { id: true }
          },
          team: {
            select: { 
              id: true,
              franchise: {
                select: { id: true }
              }
            }
          }
        }
      });

      if (!currentUser) {
        return Error('Current user not found', 404);
      }

      // Get franchise ID from either direct assignment or through team
      const userFranchiseId = currentUser.franchise?.id || currentUser.team?.franchise?.id;
      
      // Non-admin users can only see their franchise's sales
      if (!userFranchiseId) {
        return Error('Current user is not associated with any franchise', 400);
      }
      where.franchiseId = userFranchiseId;
    }
    
    if (search) {
      where.OR = [
        { invoiceNo: { contains: search } },
        {
          franchise: {
            name: { contains: search }
          }
        }
      ];
    }
    if (startDate || endDate) {
      where.invoiceDate = {};
      if (startDate) where.invoiceDate.gte = new Date(startDate);
      if (endDate) where.invoiceDate.lte = new Date(endDate);
    }
    const result = await paginate({
      model: prisma.sale,
      where,
      orderBy: { invoiceDate: 'desc' },
      page,
      perPage,
      select: {
        id: true,
        invoiceNo: true,
        invoiceDate: true,
        totalAmount: true,
        transport: {
          select: {
            id: true,
            status: true,
          },
        },
        franchise: {
          select: { name: true }
        },
        _count: {
          select: { saleDetails: true }
        }
      }
    });

    return Success(result);
  } catch (error) {
    console.error('Error fetching sales:', error);
    return Error('Failed to fetch sales');
  }
}
// POST /api/sales
export async function POST(req: NextRequest) {
  const auth = await guardApiAccess(req);
  if (!auth.ok) return auth.response;
  try {
    const body = await req.json();
    
    
    const data = createSaleSchema.parse(body) as CreateSaleInput;
    
    // Start a transaction
    const result = await prisma.$transaction(async (tx: any) => {
      const detailsData = data.saleDetails.map((detail) => {
        const quantity = Number(detail.quantity) || 0;
        const rate = Number(detail.rate) || 0;
        return {
          medicineId: detail.medicineId,
          batchNumber: detail.batchNumber,
          expiryDate: new Date(detail.expiryDate),
          quantity,
          rate,
          amount: quantity * rate,
        };
      });

      const subtotal = detailsData.reduce((sum, d) => sum + (Number(d.amount) || 0), 0);
      const discountPercent = Math.min(100, Math.max(0, Number(data.discountPercent) || 0));
      const totalAmount = Math.max(0, subtotal - subtotal * (discountPercent / 100));

      // 1. Create the sale (invoiceNo will be auto-generated by middleware)
      const sale = await tx.sale.create({
        data: {
          invoiceDate: new Date(data.invoiceDate),
          franchiseId: data.franchiseId,
          totalAmount,
          discountPercent,
          invoiceNo: '', // Temporary empty string - middleware will override this
        }
      });

      // 2. Create sale details
      const saleDetails = await tx.saleDetail.createMany({
        data: detailsData.map((detail) => ({
          saleId: sale.id,
          medicineId: detail.medicineId,
          batchNumber: detail.batchNumber,
          expiryDate: detail.expiryDate,
          quantity: detail.quantity,
          rate: detail.rate,
          amount: detail.amount,
        }))
      });

      await tx.transport.create({
        data: {
          saleId: sale.id,
          franchiseId: data.franchiseId,
          status: 'PENDING',
        },
        select: { id: true },
      });
      
      return { sale, saleDetails };
    });

    return Success(result.sale, 201);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return BadRequest(error.errors);
    }
    return Error('Failed to create sale');
  }
}